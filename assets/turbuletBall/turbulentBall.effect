// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
        # ========== 球面映射参数 ==========
        matrixRow0: { value: [1, 0, 0, 0] }
        matrixRow1: { value: [0, 1, 0, 0] }
        matrixRow2: { value: [0, 0, 1, 0] }
        matrixRow3: { value: [0, 0, 0, 1] }
        # ========== 光照参数 ==========
        # 光源方向 - 控制阴影的方向和角度
        # 默认值：(0.5, 0.8, 1.0, 0.0) 表示来自右上前方的光源，第4个分量保留
        # 视觉效果：调整XYZ分量可改变光照角度，创造不同的阴影效果
        lightDirection: { value: [0.3, -0.4, 0.6, 0.0], editor: { displayName: "光源方向" } }
        # ========== 湍流效果核心参数 ==========
        # 湍流动画速度 - 控制湍流模式的时间变化速度
        # 范围说明：0.0=静态，0.3=缓慢流动，1.0=中等速度，2.0=快速流动
        # 视觉效果：值越大湍流变化越快，产生更动感的效果
        turbulenceSpeed: { value: 0.5, range: [0.0, 2.0] }
        
        # 湍流振幅 - 控制湍流扰动的强度
        # 范围说明：0.0=无扰动，0.7=中等扰动，2.0=强烈扰动
        # 视觉效果：值越大图案扭曲变形越明显，产生更剧烈的湍流效果
        turbulenceAmplitude: { value: 0.7, range: [0.0, 2.0] }
        
        # 湍流基础频率 - 控制湍流的基本波长和尺度
        # 范围说明：0.1=大尺度缓慢变化，2.0=中等尺度，10.0=小尺度快速变化
        # 视觉效果：值越大湍流图案越密集细腻，值越小图案越粗糙宏观
        turbulenceFrequency: { value: 8.5, range: [0.1, 10.0] }
        
        # 湍流层数(倍频程) - 控制湍流的复杂度和细节层次
        # 范围说明：1.0=单层简单波动，10.0=多层复杂结构，20.0=极其细腻的分形细节
        # 视觉效果：值越大湍流越复杂，层次越丰富，但计算量也越大
        turbulenceOctaves: { value: 14.9, range: [1.0, 20.0] }
        
        # 湍流指数 - 控制频率递增的速度(分形维度)
        # 范围说明：1.0=线性递增，1.4=适中递增，3.0=指数递增
        # 视觉效果：值越大高频细节衰减越快，低频结构越突出
        turbulenceExp: { value: 1.0, range: [1.0, 3.0] }
        
        # 湍流整体强度 - 全局坐标缩放系数
        # 范围说明：0.0=无效果，1.0=标准强度，2.0=放大效果
        # 视觉效果：影响整个湍流效果的坐标范围和密度
        turbulenceIntensity: { value: 0.8, range: [0.0, 2.0] }
        
        # ========== 颜色调制参数 ==========
        # 整体颜色调制 - 影响最终输出颜色的色调
        # 默认值：白色(1,1,1,1)表示不改变原始颜色
        # 视觉效果：可以给湍流效果添加特定的颜色主题(如蓝色海洋、红色火焰等)
        overallColor: { value: [1.0, 1.0, 1.0, 1.0], editor: { type: color } }
        
        # 颜色强度倍数 - 控制颜色的亮度和饱和度
        # 范围说明：0.0=完全黑色，1.0=原始亮度，3.0=高强度发光效果
        # 视觉效果：值越大颜色越鲜艳明亮，可产生发光或过曝效果
        colorIntensity: { value: 1.0, range: [0.4, 1.5] }
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;

  #include <alpha-test>
  #include <texture>
  #include <cc-global>

  in vec4 v_color;
  in vec2 v_uv0;

  uniform sampler2D texture;

  // 球面映射参数
  uniform mat4Param {
    vec4 matrixRow0;
    vec4 matrixRow1;
    vec4 matrixRow2;
    vec4 matrixRow3;
  };

  // 光照参数
  uniform LightingParam {
    vec4 lightDirection;  // 光源方向(xyz为方向，w分量保留)
  };

  // 湍流效果参数
  uniform Turbulence {
    vec4 overallColor;      // 整体颜色调制
    float turbulenceSpeed;
    float turbulenceAmplitude; 
    float turbulenceFrequency;
    float turbulenceOctaves;
    float turbulenceExp;
    float turbulenceIntensity;
    float colorIntensity;   // 颜色强度倍数
  };

  /**
   * 湍流函数 - 核心算法
   * 功能：对输入坐标应用多层湍流扰动，产生有机的流体效果
   * 
   * 原理：
   * 1. 使用分形噪声技术，叠加多个不同频率的正弦波
   * 2. 每层都旋转坐标系，避免产生明显的方向性和重复模式
   * 3. 通过时间偏移实现动画效果
   * 4. 振幅随频率递减，保持大尺度结构的同时增加细节
   */
  vec2 turbulence(vec2 p)
  {
      // 初始化频率（从基础频率开始，每层递增）
      float freq = turbulenceFrequency;
      
      // 旋转矩阵：角度约为36.87度 (arctan(0.8/0.6))
      // 这个角度是精心选择的，能产生自然的湍流效果
      mat2 rot = mat2(0.6, -0.8, 0.8, 0.6);
      
      // === 多层湍流叠加循环 ===
      // 这是分形噪声的核心：多个不同尺度的噪声层叠加
      // 注意：使用固定的最大循环次数以兼容所有GLSL版本
      for(float i = 0.0; i < 20.0; i++)
      {
          // 动态控制实际执行的层数
          if(i >= turbulenceOctaves) break;
          
          // 计算当前层的相位
          // 解析：freq * (p * rot).y - 沿旋转后的y轴采样
          //      turbulenceSpeed * cc_time.x - 时间动画偏移
          //      i - 每层的相位偏移，防止层间同步
          float phase = freq * (p * rot).y + turbulenceSpeed * cc_time.x + i;
          
          // 添加垂直于旋转方向的正弦波扰动
          // rot[0] = (0.6, -0.8) 是旋转矩阵的第一列，表示新的x轴方向
          // sin(phase) 产生波动，除以freq使高频波振幅更小
          p += turbulenceAmplitude * rot[0] * sin(phase) / freq;
          
          // 为下一层准备：再次旋转坐标系
          // 累积旋转确保每层的方向都不同，产生复杂的湍流结构
          rot *= mat2(0.6, -0.8, 0.8, 0.6);
          
          // 频率递增：下一层的波长更短，细节更精细
          // 这符合湍流的分形特性：大尺度包含小尺度结构
          freq *= turbulenceExp;
      }
      
      // 返回经过湍流扰动的坐标
      return p;
  }

  /**
   * RGB to HSV 颜色空间转换函数
   * 参数：rgb - RGB颜色 [0,1]
   * 返回：hsv - HSV颜色 (H[0,1], S[0,1], V[0,1])
   */
  vec3 rgb2hsv(vec3 rgb) {
      float cmax = max(rgb.r, max(rgb.g, rgb.b));
      float cmin = min(rgb.r, min(rgb.g, rgb.b));
      float delta = cmax - cmin;
      
      vec3 hsv = vec3(0.0);
      
      // 计算色相 H
      if (delta > 0.0) {
          if (cmax == rgb.r) {
              hsv.x = mod((rgb.g - rgb.b) / delta, 6.0);
          } else if (cmax == rgb.g) {
              hsv.x = (rgb.b - rgb.r) / delta + 2.0;
          } else {
              hsv.x = (rgb.r - rgb.g) / delta + 4.0;
          }
          hsv.x /= 6.0;
      }
      
      // 计算饱和度 S
      hsv.y = (cmax > 0.0) ? delta / cmax : 0.0;
      
      // 计算明度 V
      hsv.z = cmax;
      
      return hsv;
  }

  /**
   * HSV to RGB 颜色空间转换函数
   * 参数：hsv - HSV颜色 (H[0,1], S[0,1], V[0,1])
   * 返回：rgb - RGB颜色 [0,1]
   */
  vec3 hsv2rgb(vec3 hsv) {
      float h = hsv.x * 6.0;
      float s = hsv.y;
      float v = hsv.z;
      
      float c = v * s;
      float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));
      float m = v - c;
      
      vec3 rgb = vec3(0.0);
      
      if (h < 1.0) {
          rgb = vec3(c, x, 0.0);
      } else if (h < 2.0) {
          rgb = vec3(x, c, 0.0);
      } else if (h < 3.0) {
          rgb = vec3(0.0, c, x);
      } else if (h < 4.0) {
          rgb = vec3(0.0, x, c);
      } else if (h < 5.0) {
          rgb = vec3(x, 0.0, c);
      } else {
          rgb = vec3(c, 0.0, x);
      }
      
      return rgb + m;
  }

  /**
   * 程序化颜色生成函数 - 明暗分离控制版本
   * 功能：只调制HSV中的V（明度），保持H（色相）和S（饱和度）不变
   * 特点：分别控制变亮和变暗的幅度，提供更精细的明度调节
   * 
   * 控制参数：
   * - brightenRange: 变亮范围（默认15%）
   * - darkenRange: 变暗范围（默认5%）
   */
  vec3 generateProceduralColor(vec2 turbulentPos)
  {
      // 获取基础颜色并应用颜色强度
      vec3 baseColor = overallColor.rgb * colorIntensity;
      
      // 转换到HSV颜色空间
      vec3 hsv = rgb2hsv(baseColor);
      
      // 计算湍流亮度调制因子
      float brightness = dot(cos(turbulentPos * 3.0), sin(-turbulentPos.yx * 3.0 * 0.618)) + 2.0;
      
      // 根据原始明度动态确定变化范围，明暗分开控制
      float originalValue = hsv.z;
      
      // 分别定义变亮和变暗的幅度（可独立调节）
      const float brightenRange = 0.15;  // 变亮范围：15%
      const float darkenRange = 0.05;    // 变暗范围：5%
      
      // 计算基于原始明度的分离变化范围
      float minValue = max(0.1, originalValue - darkenRange);   // 下限：原值-darkenRange
      float maxValue = min(1.0, originalValue + brightenRange); // 上限：原值+brightenRange
      
      // 将brightness值标准化到[-1,1]
      float normalizedBrightness = clamp((brightness - 2.0) / 2.0, -1.0, 1.0);
      
      // 根据brightness正负值分别应用不同的变化范围
      float adjustedValue;
      if (normalizedBrightness >= 0.0) {
          // 正值：变亮，使用brightenRange
          adjustedValue = originalValue + normalizedBrightness * brightenRange;
      } else {
          // 负值：变暗，使用darkenRange
          adjustedValue = originalValue + normalizedBrightness * darkenRange;
      }
      
      // 应用调制后的明度值，确保在合理范围内
      hsv.z = clamp(adjustedValue, minValue, maxValue);
      
      // 转换回RGB颜色空间
      return hsv2rgb(hsv);
  }

  /**
   * 球面光照计算函数 - 平滑阴影版本
   * 功能：根据球面法向量和光源方向计算平滑的光照强度
   * 
   * 参数：
   * @param spherePos - 标准化的球面坐标
   * @return 光照强度系数 [0.2, 1.0]
   * 
   * 原理：
   * 1. 使用朗伯光照模型计算基础光照：dot(normal, lightDir)
   * 2. 使用smoothstep(-0.2, 0.3, lightIntensity)创建平滑过渡：
   *    - 当lightIntensity < -0.2时，输出0（完全阴影）
   *    - 当lightIntensity > 0.3时，输出1（完全光照）
   *    - 在-0.2到0.3之间平滑插值，消除硬阴影边界
   * 3. 结合环境光确保最暗区域仍有基础亮度
   * 
   * 注意：此系数用于调制湍流纹理亮度，通过公式 proceduralColor * (0.7 + 0.3 * lightingFactor)
   *      确保湍流纹理在阴影区域仍保持70%的基础可见度
   */
  float calculateLighting(vec3 spherePos)
  {
      // 球面法向量（球面坐标本身就是归一化的法向量）
      vec3 normal = normalize(spherePos);
      
      // 归一化光源方向（使用xyz分量，忽略w分量）
      vec3 lightDir = normalize(lightDirection.xyz);
      
      // 朗伯光照模型：计算法向量与光源方向的点积
      float lightIntensity = dot(normal, lightDir);
      
      // 光照常量定义（按您的要求使用常量）
      const float ambientLight = 0.2;    // 环境光强度（降低以增强对比度）
      const float shadowStrength = 1.0;  // 阴影强度（提高以增强效果）
      
      // 使用smoothstep创建平滑的阴影过渡，避免硬边界
      // lightIntensity 范围从 [-1, 1]
      // smoothstep(-0.2, 0.3, lightIntensity) 在-0.2到0.3之间创建平滑过渡
      // 这样可以消除明显的阴影边界
      float smoothLighting = smoothstep(-0.2, 0.3, lightIntensity);
      
      // 最终光照 = 环境光 + 平滑的方向光
      float finalLighting = ambientLight + smoothLighting * shadowStrength;
      
      return finalLighting;
  }

  void main () {
    vec4 o = vec4(1, 1, 1, 1);

    // === 球面坐标计算 ===
    // 将UV坐标转换为标准化的球面坐标 (-1 到 1)
    vec2 xy = v_uv0 * 2.0 - 1.0;
    
    float len = length(xy);
    // 丢弃球体外部的像素
    if (len > 1.0) {
      discard;
    }

    // 计算球面的Z坐标
    float z = sqrt(1.0 - len * len);
    vec3 spherePos = vec3(xy, z);

    // === 应用旋转矩阵 ===
    mat4 b_matrix = mat4(matrixRow0, matrixRow1, matrixRow2, matrixRow3);
    vec4 rotatePos = b_matrix * vec4(spherePos, 1.0);
    vec3 p3d = rotatePos.xyz;

    // === 坐标系统转换 ===
    // 将旋转后的3D球面坐标转换为湍流坐标输入
    // 球面前后都使用同样的湍流映射逻辑
    vec2 centeredCoord = p3d.xy * turbulenceIntensity;
    
    // === 应用湍流变换 ===
    vec2 turbulentPos = turbulence(centeredCoord);
    
    // 程序化颜色生成模式（类似turbulent.effect）
    vec3 proceduralColor = generateProceduralColor(turbulentPos);
    
    // === 应用光照效果 ===
    // 计算球面光照强度
    float lightingFactor = calculateLighting(spherePos);
    
    // 分离光照和纹理：保持湍流纹理的基础亮度，光照作为调制
    // 公式：基础亮度(0.7) + 光照调制(0.3 * lightingFactor)
    // 这样确保即使在阴影区域，湍流纹理仍然可见
    vec3 litColor = proceduralColor * (0.7 + 0.3 * lightingFactor);
    
    o = vec4(litColor, 1.0);

    o *= v_color;

    ALPHA_TEST(o);

    // === 边缘软化效果 ===
    // 在球体边缘应用平滑的透明度渐变
    float alpha = smoothstep(1.0, 0.9, len);
    o.a *= alpha;

    #if USE_BGRA
      gl_FragColor = o.bgra;
    #else
      gl_FragColor = o.rgba;
    #endif
  }
}%
